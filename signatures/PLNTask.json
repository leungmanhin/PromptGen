{
  "name": "PLNTask",
  "signature_class_def": "class PLNTask(dspy.Signature):\r\n    \"\"\"\r\n    Convert the given English text to PLN.\r\n\r\n    If it is a question posted to the system, construct one or more queries that aims to find the answer from the knowledge base via reasoning.\r\n    If it is a statement, construct one or more statements to be added as a rule or knowledge to the knowledge base.\r\n\r\n    Some pre-defined predicates and their corresponding type definitions are:\r\n    (: Implication (-> (: $implicant Type) (: $consequent Type) Type))\r\n    (: And (-> (: $a Type) (: $b Type) Type))\r\n    (: Or (-> (: $a Type) (: $b Type) Type))\r\n    (: Equivalence (-> (: $a Type) (: $b Type) Type))\r\n    (: WithTV (-> (: $a Type) TV Type))\r\n    (: STV (-> (: $strength Number) (: $confidence Number) TV))\r\n    (: & (-> (: $modifier1 (-> (: $obj1 Object) Type)) (: $modifier2 (-> (: $obj2 Object) Type)) Type))\r\n    (: AtTime (-> (: $event Type) (: $time Object) Type))\r\n    (: LocationOf (-> (: $location Object) (: $obj Object) Type))\r\n\r\n    All queries or statements should be wrapped in WithTV.\r\n    Example Statement:\r\n    (: proof_name (WithTV (Predicate object) (STV 1.0 1.0)))\r\n    Example Query:\r\n    (: $query (WithTV (Predicate object) $tv))\r\n    meaning 'try to find a proof ($query) that Predicate applies to object and get me the $tv'.\r\n    Predicate or object could also be variables in a query.\r\n\r\n    General conventions for predicates:\r\n    - a corresponding type definition should be created for any new predicate being created\r\n    - if the predicate is a noun, e.g. `(Pred x)`, that means 'x is a Pred'; or `(Pred x1 x2)` means 'x1 is a Pred, and x2 adds additional information to this is-a relation'\r\n    - if the predicate is a verb, e.g. `(Pred y)`, that means 'y performs the action Pred'; in this case Pred can also take more than one argument as needed if the action involves more than one entity\r\n    - if the predicate is a modifier (e.g. adjective, adverb), e.g. `(Pred z)`, that means 'z has the property/attribute/charateristic of Pred'\r\n    - use the lemma form of the word as the name of the predicate\r\n    - a noun/verb can also be combined with the preposition being used together with it to form a multi-word predicate if it is strictly needed to convey that particular meaning as given in the text, but generally all the predicates should be named and semantically used as a single English word as much as possible\r\n    - the predicate should be created and named following this reading pattern, e.g. `(Pred x y)` should be understood as 'x Pred y'; `(PredPrep x y z)` should be understood as 'x Pred y Prep z', and so on\r\n    - if the clause given is in passive voice, change and represent it in its active voice form\r\n\r\n    To denote a variable, prefix the variable name with a '$' symbol.\r\n\r\n    AtTime is used to represent time-related information, e.g. '(AtTime x y)' means 'x happened/happens/will happen at time y'.\r\n\r\n    LocationOf is used to represent location-related information, e.g. '(LocationOf x y)' means 'x is the location of y'.\r\n    \"\"\"\r\n    similar = dspy.InputField(desc=\"Similar sentences for reference\")\r\n    previous = dspy.InputField(desc=\"Previous sentences for reference and to reuse object\")\r\n    english = dspy.InputField(desc=\"English text to convert to PLN\")\r\n    pln_types = dspy.OutputField(desc=\"PLN type definitions\")\r\n    pln_statements = dspy.OutputField(desc=\"PLN statements\")\r\n    pln_queries = dspy.OutputField(desc=\"PLN query\")",
  "description": "Convert English to PLN (Probabilistic Logic Network) syntax",
  "input_fields": [
    "similar",
    "previous",
    "english"
  ],
  "output_fields": [
    "pln_types",
    "pln_statements",
    "pln_queries"
  ],
  "field_processors": {}
}