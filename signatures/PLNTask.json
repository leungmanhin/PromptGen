{
  "name": "PLNTask",
  "signature_class_def": "class PLNTask(dspy.Signature):\r\n    \"\"\"\r\n    Convert the given English to PLN.\r\n    If it is a question, construct one or more queries to answer it.\r\n    If it is a statement, construct one or more statements to add the knowledge to the knowledge base.\r\n    Provide type definitions for all predicates being created.\r\n\r\n    Some pre-defined predicates and their corresponding type definitions are:\r\n    (: Implication (-> (: $implicant Type) (: $consequent Type) Type))\r\n    (: And (-> (: $a Type) (: $b Type) Type))\r\n    (: Or (-> (: $a Type) (: $b Type) Type))\r\n    (: Equivalence (-> (: $a Type) (: $b Type) Type))\r\n    (: WithTV (-> (: $a Type) TV Type))\r\n    (: STV (-> (: $strength Number) (: $confidence Number) TV))\r\n    (: & (-> (: $modifier1 (-> (: $obj1 Object) Type)) (: $modifier2 (-> (: $obj2 Object) Type)) Type))\r\n    (: AtTime (-> (: $event Type) (: $time Object) Type))\r\n    (: LocationOf (-> (: $location Object) (: $obj Object) Type))\r\n\r\n    All queries or statements should be wrapped in WithTV.\r\n    Example Statement:\r\n    (: proof_name (WithTV (Predicate object) (STV 1.0 1.0)))\r\n    Example Query :\r\n    (: $query (WithTV (Predicate object) $tv))\r\n    meaning 'try to find a proof ($query) that Predicate applies to object and get me the $tv'.\r\n    Predicate or object could also be variables in a query.\r\n\r\n    General conventions for predicates:\r\n    - if the predicate is a noun, e.g. `(Pred x)`, that means 'x is a Pred'\r\n    - if the predicate is a verb, e.g. `(Pred y)`, that means 'y performs the action Pred', in this case Pred can take more than one argument if needed, it can also be combined with the preposition being used together in the given text\r\n    - if the predicate is a modifier (e.g. adjective, adverb), e.g. `(Pred z)`, that means 'z has the property/attribute/charateristic of Pred'\r\n    - use the lemma form of the word as the name of the predicate\r\n    - the predicate should be created and named following this reading pattern, e.g. `(Pred x y)` should be understood as 'x Pred y'; `(PredPrep x y z)` should be understood as 'x Pred y Prep z', and so on\r\n    - the name of the predicate should be single-worded as much as possible, and only create multi-word predicates if it is strictly necessary to convey the meaning as in the given text\r\n\r\n    To denote a variable, prefix the variable name with a '$' symbol.\r\n\r\n    AtTime is used to represent time-related information, e.g. '(AtTime x y)' means 'x happened/happens/will happen at time y'.\r\n\r\n    LocationOf is used to represent location-related information, e.g. '(LocationOf x y)' means 'x is the location of y'.\r\n    \"\"\"\r\n    similar = dspy.InputField(desc=\"Similar sentences for reference\")\r\n    previous = dspy.InputField(desc=\"Previous sentences for reference and to reuse object\")\r\n    english = dspy.InputField(desc=\"English text to convert to PLN\")\r\n    pln_types = dspy.OutputField(desc=\"PLN type definitions\")\r\n    pln_statements = dspy.OutputField(desc=\"PLN statements\")\r\n    pln_queries = dspy.OutputField(desc=\"PLN query\")",
  "description": "Convert English to PLN (Probabilistic Logic Network) syntax",
  "input_fields": [
    "similar",
    "previous",
    "english"
  ],
  "output_fields": [
    "pln_types",
    "pln_statements",
    "pln_queries"
  ],
  "field_processors": {}
}